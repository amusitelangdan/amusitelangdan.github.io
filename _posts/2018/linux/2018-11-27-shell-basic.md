---
layout: post
title: Shell 基础
category: linux
tags: [linux]
excerpt: 本文主要为大家讲解Shell基础。
---

## Shell编程系列（二）-- Shell 基础

### 一、Shell 概述

* Shell是什么？

1. **Shell是一个命令解释器**，它为用户提供了一个向Linux内核发送请求以便运行程序的界面系统级程序，用户可以用Shell来启动、挂起、停止甚至是编写一些程序。
2. Shell还是一个功能相当强大的编程语言，易编写、易调试、灵活性较强。Shell是解释执行的脚本语言，在Shell中可以直接调用Linux系统命令。

    我们使用的用于向Linux发送命令的界面就叫做Shell。我们知道，计算机能识别的指令只有0和1，所以说不管是哪一种编程语言，它进行了多少次编译、解释、加工、最终都转化成为了0110这种类似的计算机指令。
那么Shell充当的角色就是将我们输入的Linux命令进行解释说明，转换成为Linux内核所能够识别的指令，这样，Linux内核才能乖乖的为我们做事。
同样的，计算机所输出的信息也是二进制数据，Shell也会将这些二进制数据转换为方便我们理解的编程语言。
所以说，Shell的角色之一就是充当了计算机和人类之间的“翻译官”。从某种角度来讲，我们也可以将windows的操作界面称之为Shell。

### 二、Shell初体验-Hello World

编写我们第一个Shell脚本，在控制台（博主使用的是XShell工具），输入`vim hello.sh`，新建一个脚本文件并且进入编辑模式。
输入以下内容然后保存。

``` sh
#!/bin/bash
# this is my first shell program.
echo "Hello World !"
```

执行命令 `bash ./hello.sh`，控制台打印“Hello World ！”。这样我们就完成了我们第一个Shell脚本程序。
下面解释一下我们的这些代码。首先`#!/bin/bash`，它标识了下面的内容是标准的Shell脚本。第二行是注释，Shell的注释方式是前面加“**#**”。
第三行`echo`，是将指定内容进行输出的命令。可以理解为`System.out.print();`。这个脚本就是简单的进行打印输出。

### 三、Bash 的基本功能

1. 命令别名与快捷键

* 查看别名

    命令`alias`，系统会输出默认的一些命令所对应的的别名。
例如，`ll`命令所对应的原始命令就是`ls -l --color=auto`。

* 设置别名

    对于某些很长的命令，我们也可以手动设置别名。命令格式为`alias [别名]='原始命令'`。这种设定方式不是长久生效的，当计算机重启，用户注销，这些别名就会失效。
如果想要永久生效，就需要将别名设置到环境变量中。环境变量默认存储在当前用户的文件夹下的`.bashrc`文件中，输入`vi ~/.bashrc`，进入编辑模式，然后设置一个别名。
保存之后退出使用别名调用命令，并没有生效，这是因为需要注销或者重启之后环境变量才会生效。想要不重启、不注销就生效。使用命令`source ~/.bashrc`。再次使用别名，会发现已经生效了。

* 删除别名

    命令`unalias [别名]`，即可删除。和设置别名一样，这个删除也不是永久生效的，重启或者注销之后就失效了。彻底删除还是需要修改环境变量文件。

* 命令生效的顺序

    我们查看`.bashrc`文件可以发现`alias rm='rm -i'`这行代码，也就是说`rm`其实是`rm -i`的别名。那么当我们执行`rm`命令的时候，到底执行的是原始的`rm`命令，还是执行的`rm -i`命令呢？
这里就牵扯到了命令的执行顺序。命令执行的顺序如下：
    1. 用绝对路径或者相对路径执行的命令。
    2. 别名。
    3. Bash的内部命令。
    4. 按照`$PATH`环境变量定义的目录查找顺序找到的第一个命令。

    注意，别名执行的优先级是高于Bash内部命令以及外部命令的。`$PATH`所对应的命令就是外部命令，比如说，本机安装了JDK，那么`$PATH`就会多出一些Java相关的命令，例如`java`、
    `javac`等。所以说设置别名的时候需要谨慎，否则可能导致系统某些命令被覆盖。

* 快捷键

    常用快捷键如下：

    |   命令   |           描述         |
    |----------| :-------------------: |
    | ctrl + c | 强制终止当前命令        |
    | ctrl + l | 清屏                   |
    | ctrl + a | 光标移动到命令行首      |
    | ctrl + e | 光标移动到命令行尾       |
    | ctrl + u | 从光标所在位置删除到行首 |
    | ctrl + z | 把命令放入后台          |
    | ctrl + r | 在历史命令中搜索        |

2. 历史命令

* 我们可以在终端输入`history`命令来查看执行过的历史命令。每一个用户都拥有一个用于保存自己历史命令的文件，这个文件保存在当前用户的用户目录下，名字叫**.bash_history**。
当我们执行一个命令之后，这个命令不会立即写入到历史命令文件中，而是暂时保存在内存中，当用户注销或者关机之后才会写入到历史命令文件中。
我们可以通过`history -w`手动的将我们输入过的命令同步到历史命令文件中，也可以通过`history -c`命令来清空历史命令。

* 历史命令的调用：
    1. 使用上下箭头来调用之前的历史命令
    2. 使用“!n”重复执行第N条命令。（N代表使用`history`命令之后出现的列表的序号值）
    3. 使用“!!”重复执行上一条命令
    4. 使用“!字符串”重复执行最后一条以该字符串开头的命令。

3. 多命令顺序执行

* 多命令执行顺序：

    执行顺序如下：

    | 多命令执行符 | 格式             |   作用   |
    |:-----------:|:---------------: | :---    |
    |       ;     | 命令1 ; 命令2    | 多个命令顺序执行，命令之间没有任何逻辑联系 |
    |      &&     | 命令1 && 命令2   | 逻辑与。<br/>当命令1正确执行，命令2才会执行。<br/>当命令1执行**不正确**，则命令2不会执行 |
    |     \|\|    | 命令1 \|\| 命令2 | 逻辑或。<br/>当命令1执行**不正确**，命令2才会执行。<br/>当命令1正确执行，则命令2不会执行 |

* 管道符

    使用方式：`命令1 | 命令2`，和上面的符号不同的是，管道符要求命令2必须能够操作命令1的结果。举个栗子：`ps -ef`这个命令是查看我们主机上面的进程。
那么如果我们想要查看特定的进程应该如何操作呢，这时候就可以使用管道符。比如说我们想要查看名字包含“java”的进行，就可以使用`ps -ef | grep java`命令。
其中`ps -ef`是查看进程，管道符之后`grep`是查找，查找包含“java”字符的进程，这样我们就能够得到全部包含“java”字符的进程。在后面Shell的学习中我们会大量的使用管道符。

4. Shell中特殊符号

* 通配符：

    通配符：

    | 符号|       作用     |
    |:---:|:---------------|
    |  ?  | 匹配一个任意字符 |
    |  *  | 匹配0个或者n个任意字符 |
    | []  | 匹配中括号中任意一个字符。 |
    | [-] | 匹配中括号中任意一个字符，-代表范围。例如[0-9]，就匹配数字0到9中任意一个字符 |
    | [^] | 匹配不是中括号中的任意一个字符 |

* 其他特殊符号

    其他特殊符号：

    | 符号 |       作用      |
    |:---: | :---------------- |
    |  '' | 单引号。在单引号中所有的特殊符号都没有特殊含义，例如“$”和“`”。 |
    |  "" | 双引号。在双引号中所有的特殊符号都没有特殊含义，但是“$”、“~”和“\”例外。 |
    |  `` | 反引号，键盘“Esc”下面那个按键。被反引号包含的内容是系统命令。<br/>在Bash中会先执行它，他的作用和“$()”一样，推荐使用后者，因为前者容易和单引号混淆。 |
    | $() | 和反引号作用一样，用来引用系统命令。 |
    |  #  | 在Shell脚本中，用于注释。 |
    |  $  | 用于调用变量的值。 |
    |  \  | 转义符。 |

    Shell的基础内容就介绍到这里，有疑问的同学欢迎评论或者私信我，没疑问但是想搞基的也可以联系我，但是我真的不搞基。
喜欢我的文章那就打赏博主一杯咖啡钱吧~~~
